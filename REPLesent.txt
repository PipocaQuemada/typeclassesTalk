| \gTypeclasses 101

How to make ad hoc polymorphism less ad hoc

---

| History and motivation

Invented by Phil Wadler in '88 in the paper "how to make ad hoc polymorphism less ad hoc" to solve 2 problems for Haskell:

* overloading equality operators

* overloading numeric operators

---

| What are type classes?

Similar to interfaces, but

- In OO, vtables/methods are bundled with data 

- With typeclasses, they're deliberately separated

---

| What do typeclasses look like in Haskell?

class Eq a where
    (==) :: a -> a -> Bool

instance Eq Bool where
    True == True = True
    False == False = True
    _ == _ = False

member :: Eq a => a -> [a] -> Bool

---

| What do typeclasses look like in Scala?
```
trait Eq[A] {
  def ===(x: A, y: A): Boolean
}

// Optional, but provides a more natural syntax
final case class EqOps[A](a: A)(implicit eq: Eq[A]){
  def ===(other: A) = eq.===(a, other)
}
object EqSyntax {
  implicit def eqSyntax[A](x: A)(implicit eq: Eq[A]) = EqOps(x)
} 

sealed trait Foo 
object Foo {
  implicit val eqInstance = new Eq[Foo] {
    def ===(x: Foo, y: Foo) = (x, y) match {
      case (Bar(), Bar()) => true
      case (Baz(), Baz()) => true
      case _ => false
    }
  }
}

case class Bar() extends Foo
case class Baz() extends Foo
 
val bar: Foo = Bar()
val baz: Foo = Baz()
import EqSyntax._
---

| How does this differ from normal OO?

* Retroactive extension of library code

* Conditional implementation of typeclass

* Completely type directed, can be resolved statically

* No need for data to have access to implementation

* Polymorphic values / return type polymorphism

* Avoids F-bounded-polymorphism

---

| A brief digression: monoids


In math, a Monoid is a set S, a closed binary associative operation *, and an identity element i

Associative means (a + b) + c == a + (b + c)

Identity means a * i == a == i * a

examples: (Int, +, 0), (Int, *, 1), (Bool, &&, true), 
(Bool, ||, false), (Set[A], union, Set.empty), 
(List[A], ++, List.empty), (a => a, compose, id) 

---
```
trait Monoid[A] {
  val id: A
  def <>(x:A , y:A): A
}

final case class MonoidOps[A](x: A)(implicit M: Monoid[A]){
  def <>(y: A) = <>(x, y)
}
object MonoidSyntax{
  implicit def monoidSyntax[A](a: A)(implicit M: Monoid[A]) = MonoidOps(a)
}

---

| Conditional implementation

```
object MonoidInstances {

  implicit def functionMonoid[A, B](implicit bMonoid: Monoid[B]): new Monoid[A => B] {
    val id = a => bMonoid.id
    val <>(x: A => B, y: A => B) = a => <>(x(a), y(a))
  }

  implicit def tupleMonoid[A, B](implicit aMonoid: Monoid[A], bMonoid: Monoid[B]) = new Monoid[(A, B)] {
    val id = (id, id)
    def <>(x: (A, B), y: (A, B)) = (x, y) match {
      case ((xa, xb), (ya, yb)) => (<>(xa, ya), <>(xb, yb))
    }
  }
}

---

| Polymorphic values








