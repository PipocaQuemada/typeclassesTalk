| \gTypeclasses 101

How to make ad hoc polymorphism less ad hoc

---

| What are type classes?

OO's big idea: bundling implementation and data is good 

Typeclass's big idea: separating implementation from data is good.

---

| History and motivation

Invented by Phil Wadler in '88 in the paper "how to make ad hoc polymorphism less ad hoc" to
solve 2 problems for Haskell:

* overloading equality operators

* overloading numeric operators


---

| What do typeclasses look like in Haskell?

class Eq a where
    (==) :: a -> a -> Bool

instance Eq Bool where
    True == True = True
    False == False = True
    _ == _ = False

member :: Eq a => a -> [a] -> Bool

---

| What do typeclasses look like in Scala?
```
trait Eq[A] {
  def ===(x: A, y: A): Boolean
}

// Optional, but provides a more natural syntax
final case class EqOps[A](a: A)(implicit eq: Eq[A]){
  def ===(other: A) = eq.===(a, other)
}
object EqSyntax {
  implicit def eqSyntax[A](x: A)(implicit eq: Eq[A]) = EqOps(x)
} 

sealed trait Foo 
object Foo {
  implicit val eqInstance = new Eq[Foo] {
    def ===(x: Foo, y: Foo) = (x, y) match {
      case (Bar(), Bar()) => true
      case (Baz(), Baz()) => true
      case _ => false
    }
  }
}

case class Bar() extends Foo
case class Baz() extends Foo
 
val bar: Foo = Bar()
val baz: Foo = Baz()
import EqSyntax._

---

| How does this differ from "normal" OO?

* Retroactive extension of library code

* Conditional implementation of typeclass

* Completely type directed, can be resolved statically

* No need for data to have access to implementation

* Polymorphic values / return type polymorphism

* Avoids F-bounded-polymorphism

---

| Retroactive extension of library code

In OO, you can't make a library class extend a new interface.
The best you can do is create a new subclass that implements the interface.

However, the library won't return values of that subclass, so you'll need to
do a lot of wrapping.

With typeclasses, you can provide an implementation in the library that defines
the new typeclass, or in your own application codebase.

---
| A brief digression: monoids


In math, a Monoid is a set S, a closed binary associative operation *, 
and an identity element i.

Associative means (a + b) + c == a + (b + c)

Identity means a * i == a == i * a

examples: (Int, +, 0), (Int, *, 1), (Bool, &&, true), 
(Bool, ||, false), (Set[A], union, Set.empty), 
(List[A], ++, List.empty), (a => a, compose, id) 

---
```
trait Monoid[A] {
  val id: A
  def <>(x:A , y:A): A
}

final case class MonoidOps[A](x: A)(implicit M: Monoid[A]){
  def <>(y: A) = <>(x, y)
}
object MonoidSyntax{
  implicit def monoidSyntax[A](a: A)(implicit M: Monoid[A]) = MonoidOps(a)
}

---

| No need for data to have access to implementation

```

def foldM(list: List[A])(implicit m: Monoid[A]) =
  list.fold(m.id)(_ <> _)
---

| Conditional implementation

```
object MonoidInstances {

  implicit def functionMonoid[A, B](implicit bMonoid: Monoid[B]): new Monoid[A => B] {
    val id = a => bMonoid.id
    val <>(x: A => B, y: A => B) = a => <>(x(a), y(a))
  }

  implicit def tupleMonoid[A, B](implicit aMonoid: Monoid[A], bMonoid: Monoid[B]) = 
    new Monoid[(A, B)] {
      val id = (id, id)
      def <>(x: (A, B), y: (A, B)) = (x, y) match {
        case ((xa, xb), (ya, yb)) => (<>(xa, ya), <>(xb, yb))
      }
    }
}

---

| Polymorphic values

---

| Naive OO Monoid trait

```
trait Monoid {
  val id: Monoid
  def <>(other:Monoid): Monoid
}

case class MyString(s: String) extends Monoid {
  val id: Monoid = MyString("")
  def <>(other:Monoid): Monoid =
    other match {
      case MyString(s2) => MyString(s + s2)
      case _ => throw new Exception("expected another MyString in <>")
    }
}

// Problem: `MyInt(1) <> MyString("1")` compiles, but isn't sensible.

---

| F-bounded OO Monoid trait

* An F-bound is a recursive bound on a generic parameter


```
trait Monoid[A :> Monoid[A]] {
  val id: A
  def <>(other: A): A
}

case class MyString(s: String) extends Monoid[MyString]{
  val id: MyString
  val <>(other: MyString) = Mystring(s + other.s)
}
